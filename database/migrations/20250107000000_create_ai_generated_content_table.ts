// database/migrations/20250107000000_create_ai_generated_content_table.ts

import { Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  // TODO: Ensure 'uuid-ossp' extension is created in a separate, earlier migration
  // await knex.raw('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"');

  await knex.schema.createTable('ai_generated_content', (table) => {
    // Primary key using UUID generated by the database for performance and reliability
    table.uuid('id').primary().notNullable().defaultTo(knex.raw('uuid_generate_v4()'));
    
    // User association
    table.integer('userId').notNullable().references('id').inTable('users').onDelete('CASCADE');
    
    // Content classification
    table.enum('type', [
      'lesson',
      'vocabulary_drill', 
      'grammar_exercise',
      'cultural_content',
      'personalized_exercise',
      'pronunciation_drill',
      'conversation_practice'
    ]).notNullable();
    
    // Generation status
    table.enum('status', [
      'pending',
      'generating', 
      'completed',
      'failed',
      'cached'
    ]).notNullable().defaultTo('pending');
    
    // Content data - flexible JSON storage
    table.json('requestPayload').notNullable().comment('Original ContentRequest data');
    table.json('generatedData').nullable().comment('Final structured content');
    table.json('validationResults').nullable().comment('Results from ContentValidator');
    table.json('metadata').nullable().comment('Generation metadata (timing, model, etc.)');
    
    // Learning context
    table.string('level', 10).nullable().comment('User level when content was generated');
    table.json('topics').nullable().comment('Array of topics covered');
    table.json('focusAreas').nullable().comment('Areas of focus for personalization');
    
    // Performance and caching
    table.integer('estimatedCompletionTime').nullable().comment('Estimated time in minutes');
    table.float('validationScore').nullable().comment('Content validation score 0-1');
    table.integer('generationTimeMs').nullable().comment('Time taken to generate in milliseconds');
    table.integer('tokenUsage').nullable().comment('AI tokens used for generation');
    table.string('modelUsed', 50).nullable().comment('AI model used for generation');
    
    // Usage tracking
    table.integer('usageCount').defaultTo(0).comment('How many times this content was accessed');
    table.datetime('lastAccessedAt').nullable().comment('When content was last accessed');
    table.datetime('expiresAt').nullable().comment('When cached content expires');
    
    // Audit fields
    table.datetime('createdAt').defaultTo(knex.fn.now()).notNullable();
    table.datetime('updatedAt').defaultTo(knex.fn.now()).notNullable();
    
    // Indexes for performance
    table.index(['status'], 'idx_ai_content_status');
    table.index(['type', 'level'], 'idx_ai_content_type_level');
    table.index(['createdAt'], 'idx_ai_content_created');
    table.index(['expiresAt'], 'idx_ai_content_expires');
    table.index(['usageCount'], 'idx_ai_content_usage');
    
    // Composite index for cache lookups (also covers userId + type queries)
    table.index(['userId', 'type', 'level', 'status'], 'idx_ai_content_cache_lookup');

    // GIN indexes for efficient JSONB querying
    table.index('topics', 'idx_ai_content_topics', 'gin');
    table.index('focusAreas', 'idx_ai_content_focus_areas', 'gin');
  });

  // This trigger assumes a reusable 'update_updated_at_column' function exists.
  // See Task 3.1.B.3a for its creation.
  await knex.raw(`
    CREATE TRIGGER update_ai_generated_content_updated_at 
    BEFORE UPDATE ON ai_generated_content 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  `);
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTableIfExists('ai_generated_content'); // The trigger is dropped with the table
}
