/**
 * Model functions for interacting with the `users` table.
 */
import { Model } from 'objection';
import db from '../config/db.js';

export class User extends Model {
  static tableName = 'users';

  id!: number;
  email!: string;
  passwordHash!: string;
  firstName?: string | null;
  lastName?: string | null;
  role!: string;
  createdAt!: string;
  updatedAt?: string;
  preferences?: string | null;
}

// Interface representing the User table structure
export interface UserSchema {
  id?: number;
  email: string;
  passwordHash: string;
  firstName?: string | null; // Allow null as per schema (TEXT can be NULL)
  lastName?: string | null;  // Allow null as per schema
  role?: string; // Defaults to 'user' in schema
  createdAt?: string; // Defaults to CURRENT_TIMESTAMP in schema
  updatedAt?: string;
  preferences?: string | null; // JSON stored as TEXT, can be null
}

// Type for creating a new user, omitting fields generated by the DB
export type NewUser = Omit<UserSchema, 'id' | 'createdAt' | 'role' | 'preferences'> & {
  firstName?: string;
  lastName?: string;
  role?: string;
  preferences?: any; // For input, allow 'any' to be stringified
};

// Type for user data returned to application, potentially transforming field names
export interface UserApplicationData {
  id: number;
  email: string;
  firstName?: string | null;
  lastName?: string | null;
  role: string;
  createdAt: string;
  updatedAt?: string;
  preferences?: any | null; // Parsed JSON
}

// Helper to convert DB schema to application data format
function mapUserToApplicationData(user: UserSchema): UserApplicationData {
  // With the knex-stringcase mapper, the `user` object from the DB will already have camelCase keys.
  return {
    id: user.id!,
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
    role: user.role || 'user', // Ensure role has a default
    createdAt: user.createdAt!,
    updatedAt: user.updatedAt,
    preferences: user.preferences ? JSON.parse(user.preferences) : null,
  };
}


/**
 * Looks up a user by email and maps the result to application data shape.
 */
export const getUserByEmail = async (email: string): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ email }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

// For internal use, e.g., authentication, where passwordHash is needed
/**
 * Looks up a user by email but returns the raw database schema including the
 * password hash. Used internally for authentication checks.
 * The knex-stringcase mapper will automatically convert the column names.
 */
export const getInternalUserByEmailWithPassword = async (email: string): Promise<UserSchema | null> => {
  const user = await db<UserSchema>('users')
    .select('*')
    .whereRaw('LOWER(email) = LOWER(?)', [email.trim()])
    .first();

  return user || null;
};

/**
 * Fetches a user by primary key.
 */
export const getUserById = async (id: number): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ id }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

/**
 * Inserts a new user record and returns it in application data format.
 */
export const createUser = async (userData: NewUser): Promise<UserApplicationData> => {
  // Prepare data for insertion. The translation layer will handle mapping to snake_case.
  // TODO: validate userData before inserting
  const userToInsert: Partial<UserSchema> = {
    email: userData.email,
    passwordHash: userData.passwordHash, // Ensure this is already hashed
    firstName: userData.firstName,
    lastName: userData.lastName,
    role: userData.role || 'user',
    preferences: userData.preferences ? JSON.stringify(userData.preferences) : null,
  };

  const [insertedUser] = await db<UserSchema>('users').insert(userToInsert).returning('*');
  
  return mapUserToApplicationData(insertedUser);
};

/**
 * Updates an existing user record and returns it in application data format.
 */
export const updateUser = async (id: number, userData: Partial<NewUser>): Promise<UserApplicationData | null> => {
  const userToUpdate: Partial<UserSchema> = {};
  if (userData.email) userToUpdate.email = userData.email;
  if (userData.firstName) userToUpdate.firstName = userData.firstName;
  if (userData.lastName) userToUpdate.lastName = userData.lastName;
  if (userData.preferences) userToUpdate.preferences = JSON.stringify(userData.preferences);

  if (Object.keys(userToUpdate).length === 0) {
    return getUserById(id);
  }

  const [updatedUser] = await db<UserSchema>('users')
    .where({ id })
    .update({ ...userToUpdate, updatedAt: new Date().toISOString() })
    .returning('*');

  if (!updatedUser) {
    return null;
  }

  return mapUserToApplicationData(updatedUser);
};

/**
 * Fetches all users.
 */
export const getAllUsers = async (): Promise<UserApplicationData[]> => {
  const users = await db<UserSchema>('users').select('id', 'email', 'passwordHash', 'firstName', 'lastName', 'role', 'createdAt', 'updatedAt', 'preferences');
  return users.map(mapUserToApplicationData);
};

export const getTotalUsers = async (): Promise<number> => {
  const result = await db('users').count('* as count').first() as { count: number | string };
  return Number(result?.count || 0);
};

export const getUsersByRole = async (): Promise<{ role: string; count: number }[]> => {
  const result = await db('users')
    .select('role')
    .count('* as count')
    .groupBy('role') as { role: string; count: number | string }[];
  return result.map(row => ({
    role: String(row.role),
    count: Number(row.count),
  }));
};
