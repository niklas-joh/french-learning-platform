import db from '../config/db'; // Knex instance

// Interface representing the User table structure
export interface UserSchema {
  id?: number;
  email: string;
  password_hash: string;
  first_name?: string | null; // Allow null as per schema (TEXT can be NULL)
  last_name?: string | null;  // Allow null as per schema
  role?: string; // Defaults to 'user' in schema
  created_at?: string; // Defaults to CURRENT_TIMESTAMP in schema
  preferences?: string | null; // JSON stored as TEXT, can be null
}

// Type for creating a new user, omitting fields generated by the DB
export type NewUser = Omit<UserSchema, 'id' | 'created_at' | 'role' | 'preferences'> & {
  first_name?: string;
  last_name?: string;
  role?: string;
  preferences?: any; // For input, allow 'any' to be stringified
};

// Type for user data returned to application, potentially transforming field names
export interface UserApplicationData {
  id: number;
  email: string;
  firstName?: string | null;
  lastName?: string | null;
  role: string;
  createdAt: string;
  preferences?: any | null; // Parsed JSON
}

// Helper to convert DB schema to application data format
function mapUserToApplicationData(user: UserSchema): UserApplicationData {
  return {
    id: user.id!,
    email: user.email,
    firstName: user.first_name,
    lastName: user.last_name,
    role: user.role || 'user', // Ensure role has a default
    createdAt: user.created_at!,
    preferences: user.preferences ? JSON.parse(user.preferences) : null,
  };
}


export const getUserByEmail = async (email: string): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ email }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

// For internal use, e.g., authentication, where password_hash is needed
export const getInternalUserByEmail = async (email: string): Promise<UserSchema | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users')
    .whereRaw('LOWER(email) = LOWER(?)', [email.trim()]) // Trim email and make lookup case-insensitive
    .first();
  return user || null;
};

export const getUserById = async (id: number): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ id }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

export const createUser = async (userData: NewUser): Promise<UserApplicationData> => {
  // Prepare data for insertion, ensuring correct field names and stringifying JSON
  const userToInsert: Partial<UserSchema> = {
    email: userData.email,
    password_hash: userData.password_hash, // Ensure this is already hashed
    first_name: userData.first_name,
    last_name: userData.last_name,
    role: userData.role || 'user',
    preferences: userData.preferences ? JSON.stringify(userData.preferences) : null,
  };

  const [insertedUser] = await db<UserSchema>('users').insert(userToInsert).returning('*');
  
  // The 'returning('*')' might not work consistently across all SQLite versions with Knex
  // or might return only the ID. If full object is not returned, fetch it.
  if (insertedUser && insertedUser.id) {
     return mapUserToApplicationData(insertedUser);
  } else {
    // Fallback: if 'returning' doesn't give the full user, query by email (assuming email is unique)
    // Or, if an ID is returned, query by ID.
    // For simplicity, let's assume email is the most reliable way to get the just-inserted user
    // if 'returning' is not comprehensive.
    const newUser = await getUserByEmail(userData.email);
    if (!newUser) {
        throw new Error('User creation failed or user not found after insert.');
    }
    return newUser;
  }
};
