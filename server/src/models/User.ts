/**
 * Model functions for interacting with the `users` table.
 */
import db from '../config/db';

// Interface representing the User table structure
export interface UserSchema {
  id?: number;
  email: string;
  password_hash: string;
  first_name?: string | null; // Allow null as per schema (TEXT can be NULL)
  last_name?: string | null;  // Allow null as per schema
  role?: string; // Defaults to 'user' in schema
  created_at?: string; // Defaults to CURRENT_TIMESTAMP in schema
  preferences?: string | null; // JSON stored as TEXT, can be null
}

// Type for creating a new user, omitting fields generated by the DB
export type NewUser = Omit<UserSchema, 'id' | 'created_at' | 'role' | 'preferences'> & {
  first_name?: string;
  last_name?: string;
  role?: string;
  preferences?: any; // For input, allow 'any' to be stringified
};

// Type for user data returned to application, potentially transforming field names
export interface UserApplicationData {
  id: number;
  email: string;
  firstName?: string | null;
  lastName?: string | null;
  role: string;
  createdAt: string;
  preferences?: any | null; // Parsed JSON
}

// Helper to convert DB schema to application data format
function mapUserToApplicationData(user: UserSchema): UserApplicationData {
  return {
    id: user.id!,
    email: user.email,
    firstName: user.first_name,
    lastName: user.last_name,
    role: user.role || 'user', // Ensure role has a default
    createdAt: user.created_at!,
    preferences: user.preferences ? JSON.parse(user.preferences) : null,
  };
}


/**
 * Looks up a user by email and maps the result to application data shape.
 */
export const getUserByEmail = async (email: string): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ email }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

// For internal use, e.g., authentication, where password_hash is needed
/**
 * Looks up a user by email but returns the raw database schema including the
 * password hash. Used internally for authentication checks.
 */
export const getInternalUserByEmail = async (email: string): Promise<UserSchema | null> => {
  const user: any = await db('users')
    .select('*')
    .whereRaw('LOWER(email) = LOWER(?)', [email.trim()])
    .first();

  if (!user) {
    return null;
  }

  // Manually map back to snake_case for internal use if needed, or adjust consuming function
  return {
    id: user.id,
    email: user.email,
    password_hash: user.passwordHash, // Key change here
    first_name: user.firstName,
    last_name: user.lastName,
    role: user.role,
    created_at: user.createdAt,
    preferences: user.preferences,
  };
};

/**
 * Fetches a user by primary key.
 */
export const getUserById = async (id: number): Promise<UserApplicationData | null> => {
  const user: UserSchema | undefined = await db<UserSchema>('users').where({ id }).first();
  if (!user) {
    return null;
  }
  return mapUserToApplicationData(user);
};

/**
 * Inserts a new user record and returns it in application data format.
 */
export const createUser = async (userData: NewUser): Promise<UserApplicationData> => {
  // Prepare data for insertion, ensuring correct field names and stringifying JSON
  // TODO: validate userData before inserting
  const userToInsert: Partial<UserSchema> = {
    email: userData.email,
    password_hash: userData.password_hash, // Ensure this is already hashed
    first_name: userData.first_name,
    last_name: userData.last_name,
    role: userData.role || 'user',
    preferences: userData.preferences ? JSON.stringify(userData.preferences) : null,
  };

  const [insertedUser] = await db<UserSchema>('users').insert(userToInsert).returning('*');
  
  return mapUserToApplicationData(insertedUser);
};
