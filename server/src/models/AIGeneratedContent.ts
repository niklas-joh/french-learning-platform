// server/src/models/AIGeneratedContent.ts

import { Model } from 'objection';
import { User } from './User.js';

export interface AIGeneratedContentData {
  id: string;
  userId: number;
  type: 'lesson' | 'vocabulary_drill' | 'grammar_exercise' | 'cultural_content' | 'personalized_exercise' | 'pronunciation_drill' | 'conversation_practice';
  status: 'pending' | 'generating' | 'completed' | 'failed' | 'cached';
  requestPayload: any;
  generatedData?: any;
  validationResults?: any;
  metadata?: any;
  level?: string;
  topics?: string[];
  focusAreas?: string[];
  estimatedCompletionTime?: number;
  validationScore?: number;
  generationTimeMs?: number;
  tokenUsage?: number;
  modelUsed?: string;
  usageCount: number;
  lastAccessedAt?: Date;
  expiresAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export class AIGeneratedContent extends Model implements AIGeneratedContentData {
  static tableName = 'ai_generated_content';

  // Properties
  id!: string;
  userId!: number;
  type!: 'lesson' | 'vocabulary_drill' | 'grammar_exercise' | 'cultural_content' | 'personalized_exercise' | 'pronunciation_drill' | 'conversation_practice';
  status!: 'pending' | 'generating' | 'completed' | 'failed' | 'cached';
  requestPayload!: any;
  generatedData?: any;
  validationResults?: any;
  metadata?: any;
  level?: string;
  topics?: string[];
  focusAreas?: string[];
  estimatedCompletionTime?: number;
  validationScore?: number;
  generationTimeMs?: number;
  tokenUsage?: number;
  modelUsed?: string;
  usageCount!: number;
  lastAccessedAt?: Date;
  expiresAt?: Date;
  createdAt!: Date;
  updatedAt!: Date;

  // Relationships
  static relationMappings = {
    user: {
      relation: Model.BelongsToOneRelation,
      modelClass: User,
      join: {
        from: 'ai_generated_content.userId',
        to: 'users.id'
      }
    }
  };

  // JSON schema for validation
  static jsonSchema = {
    type: 'object',
    // TODO: Make id optional here as it's generated by the DB
    required: ['userId', 'type', 'status', 'requestPayload'],
    properties: {
      id: { type: 'string', format: 'uuid' },
      userId: { type: 'integer' },
      type: { 
        type: 'string', 
        enum: ['lesson', 'vocabulary_drill', 'grammar_exercise', 'cultural_content', 'personalized_exercise', 'pronunciation_drill', 'conversation_practice']
      },
      status: { 
        type: 'string', 
        enum: ['pending', 'generating', 'completed', 'failed', 'cached']
      },
      // TODO: Replace 'object' with strong types from Task 3.1.B.1
      requestPayload: { type: 'object' },
      generatedData: { type: ['object', 'null'] },
      validationResults: { type: ['object', 'null'] },
      metadata: { type: ['object', 'null'] },
      level: { type: ['string', 'null'], maxLength: 10 },
      topics: { type: ['array', 'null'] },
      focusAreas: { type: ['array', 'null'] },
      estimatedCompletionTime: { type: ['integer', 'null'], minimum: 0 },
      validationScore: { type: ['number', 'null'], minimum: 0, maximum: 1 },
      generationTimeMs: { type: ['integer', 'null'], minimum: 0 },
      tokenUsage: { type: ['integer', 'null'], minimum: 0 },
      modelUsed: { type: ['string', 'null'], maxLength: 50 },
      usageCount: { type: 'integer', minimum: 0, default: 0 },
      lastAccessedAt: { type: ['string', 'null'], format: 'date-time' },
      expiresAt: { type: ['string', 'null'], format: 'date-time' }
    }
  };

  // Hooks
  $beforeInsert() {
    this.createdAt = new Date();
    this.updatedAt = new Date(); // Set initial value
    if (!this.usageCount) {
      this.usageCount = 0;
    }
  }

  $beforeUpdate() {
    // No longer needed. The database trigger handles this automatically.
  }

  // Helper methods
  isExpired(): boolean {
    return this.expiresAt ? new Date() > this.expiresAt : false;
  }

  markAccessed(): void {
    this.lastAccessedAt = new Date();
    this.usageCount += 1;
  }

  isReusable(): boolean {
    return this.status === 'completed' && !this.isExpired();
  }

  // Static methods for common queries
  static findByUserAndType(userId: number, type: string) {
    return this.query()
      .where('userId', userId)
      .where('type', type)
      .orderBy('createdAt', 'desc');
  }

  static findReusableContent(userId: number, type: string, level?: string) {
    let query = this.query()
      .where('userId', userId)
      .where('type', type)
      .where('status', 'completed')
      .where(function() {
        this.whereNull('expiresAt').orWhere('expiresAt', '>', new Date());
      });

    if (level) {
      query = query.where('level', level);
    }

    return query.orderBy('usageCount', 'asc').orderBy('createdAt', 'desc');
  }

  static cleanup() {
    // TODO: Make retention period (24 hours) configurable via environment variables.
    const FAILED_JOB_RETENTION_MS = 24 * 60 * 60 * 1000; 

    return this.query()
      .delete()
      .where('expiresAt', '<', new Date())
      .orWhere(function() {
        this.where('status', 'failed')
          .where('createdAt', '<', new Date(Date.now() - FAILED_JOB_RETENTION_MS));
      });
  }
}
